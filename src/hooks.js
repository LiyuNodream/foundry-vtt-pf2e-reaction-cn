import Settings from "./settings.js";

const schadenfreude = "@UUID[Compendium.pf2e.spells-srd.Item.8E97SA9KAWCNdXfO]"
const clever_gambit = "@UUID[Compendium.pf2e.feats-srd.Item.D1o7GUraoFFzjaub]"
const implements_interruption = "@UUID[Compendium.pf2e.actionspf2e.Item.dnaPJfA0CDLNrWcW]"
const ring_bell = "@UUID[Compendium.pf2e.actionspf2e.Item.ublVm5gmCIm3eRdQ]"
const amulets_abeyance = "@UUID[Compendium.pf2e.actionspf2e.Item.Or6RLXeoZkN8CLdi]"
const convincing_illusion = "@UUID[Compendium.pf2e.feats-srd.Item.bSXcyu7ExWq9qUzG]"
const scapegoat_parallel_self = "@UUID[Compendium.pf2e.feats-srd.Item.tBWSxVxrojRcEzJt]"
const ruby_resurrection = "@UUID[Compendium.pf2e.feats-srd.Item.9Slu8lSOYnDtKsIb]"
const spell_relay = "@UUID[Compendium.pf2e.feats-srd.Item.zwEaXGKqnlBTllfE]"
const cheat_death = "@UUID[Compendium.pf2e.feats-srd.Item.D2KSVHPRlBEibrV8]"
const twin_riposte = "@UUID[Compendium.pf2e.feats-srd.Item.GJIAecRq1bD2r8O0]"
const guardians_deflection_swashbuckler = "@UUID[Compendium.pf2e.feats-srd.Item.YJIzE2RhGRGfbt9j]"
const guardians_deflection_fighter = "@UUID[Compendium.pf2e.feats-srd.Item.JdCRxwgtdQkJ1Ha6]"
const farabellus_flip = "@UUID[Compendium.pf2e.feats-srd.Item.PH5b61x3iJSKP3Xi]"
const dueling_riposte = "@UUID[Compendium.pf2e.feats-srd.Item.mf2cdCRV8uowOMOm]"
const verdant_presence = "@UUID[Compendium.pf2e.feats-srd.Item.Lbpm0OrQb4u2LVtj]"
const storm_retribution = "@UUID[Compendium.pf2e.feats-srd.Item.F1DVDJRARfdb1Kjz]"
const reactive_transformation = "@UUID[Compendium.pf2e.feats-srd.Item.4Q9Q41KLPYJMdV4b]"
const fiery_retort = "@UUID[Compendium.pf2e.feats-srd.Item.6biVVoaqqUdQmQ37]"
const courageous_opportunity = "@UUID[Compendium.pf2e.feats-srd.Item.nEmaHLsZEBru1Jjv]"
const premonition_of_clarity = "@UUID[Compendium.pf2e.feats-srd.Item.2h8a6pKhXTXwpJjP]"
const rapid_response = "@UUID[Compendium.pf2e.feats-srd.Item.OcBaEnGdDm6CuSnr]"
const denier_of_destruction = "@UUID[Compendium.pf2e.feats-srd.Item.siegOEdEpevAJNFw]"
const shield_wall = "@UUID[Compendium.pf2e.feats-srd.Item.QpRzvfWdj6YH9TyE]"
const sacrifice_armor = "@UUID[Compendium.pf2e.feats-srd.Item.bYijGvCvCmJnW6aA]"
const ringmasters_introduction = "@UUID[Compendium.pf2e.feats-srd.Item.OliKxFIqzky2o6vk]"
const pirouette = "@UUID[Compendium.pf2e.feats-srd.Item.RlKGaxQWWLa7xJSc]"
const accompany = "@UUID[Compendium.pf2e.feats-srd.Item.oTTddwzF9TPNkMyd]"
const spiritual_guides = "@UUID[Compendium.pf2e.feats-srd.Item.cEu8BUS41dlPyPGW]"
const tangle_of_battle = "@UUID[Compendium.pf2e.feats-srd.Item.GLbl3qoWCvvjJr4S]"
const mage_hunter = "@UUID[Compendium.pf2e.feats-srd.Item.mqLPCNdCSNyY7gyI]"
const furious_vengeance = "@UUID[Compendium.pf2e.feats-srd.Item.Oyml3OGNy468z3XI]"
const embrace_the_pain = "@UUID[Compendium.pf2e.feats-srd.Item.j20djiiuVwUf8MqL]"
const opportune_riposte = "@UUID[Compendium.pf2e.actionspf2e.EfjoIuDmtUn4yiow]"
const perfect_clarity = "@UUID[Compendium.pf2e.feats-srd.Item.JkQjKyzfhMWLr9Gs]"
const opportune_riposte_action = "@UUID[Compendium.pf2e.actionspf2e.EfjoIuDmtUn4yiow]"
const airy_step_action = "@UUID[Compendium.pf2e.actionspf2e.akmQzZoNhyfCKFpL]"
const retaliatory_cleansing = "@UUID[Compendium.pf2e.feats-srd.Item.y7SYHv0DWkkwjT95]"
const airy_step_feat = "@UUID[Compendium.pf2e.feats-srd.Item.hOD9de1ftfYRSEKn]"
const nimble_dodge_action = "@UUID[Compendium.pf2e.bestiary-ability-glossary-srd.wCnsRCHvtZkZTmO0]"
const nimble_dodge_feat = "@UUID[Compendium.pf2e.feats-srd.Item.dNH8OHEvx3vI9NBQ]"
const fast_swallow = "@UUID[Compendium.pf2e.bestiary-ability-glossary-srd.IQtb58p4EaeUzTN1]"
const retributive_strike = "@UUID[Compendium.pf2e.bestiary-ability-glossary-srd.IQtb58p4EaeUzTN1]"
const ferocity = "@UUID[Compendium.pf2e.bestiary-ability-glossary-srd.N1kstYbHScxgUQtN]"
const attack_of_opportunity = "@UUID[Compendium.pf2e.actionspf2e.KAVf7AmRnbCAHrkT]"
const no_escape = "@UUID[Compendium.pf2e.feats-srd.Item.lT8XlX1Ig900BblS]"
const glimpse_of_redemption = "@UUID[Compendium.pf2e.actionspf2e.tuZnRWHixLArvaIf]"
const wicked_thorns = "@UUID[Compendium.pf2e.actionspf2e.ncdryKskPwHMgHFh]"
const iron_command = "@UUID[Compendium.pf2e.actionspf2e.M8RCbthRhB4bxO9t]"
const selfish_shield = "@UUID[Compendium.pf2e.actionspf2e.enQieRrITuEQZxx2]"
const destructive_vengeance = "@UUID[Compendium.pf2e.actionspf2e.r5Uth6yvCoE4tr9z]"
const liberating_step = "@UUID[Compendium.pf2e.actionspf2e.IX1VlVCL5sFTptEE]"
const knights_retaliation = "@UUID[Compendium.pf2e.feats-srd.Item.jZy91ekcS9ZqmdEH]"
const mirror_shield = "@UUID[Compendium.pf2e.feats-srd.Item.kQEIPYoKTt69yXxV]"
const reactive_shield = "@UUID[Compendium.pf2e.feats-srd.Item.w8Ycgeq2zfyshtoS]"
const charmed_life = "@UUID[Compendium.pf2e.feats-srd.Item.DkoxNw9tsFFXrfJY]"

const identifySkills = new Map([
    ["aberration", ["occultism"]],
    ["animal", ["nature"]],
    ["astral", ["occultism"]],
    ["beast", ["arcana", "nature"]],
    ["celestial", ["religion"]],
    ["construct", ["arcana", "crafting"]],
    ["dragon", ["arcana"]],
    ["elemental", ["arcana", "nature"]],
    ["ethereal", ["occultism"]],
    ["fey", ["nature"]],
    ["fiend", ["religion"]],
    ["fungus", ["nature"]],
    ["humanoid", ["society"]],
    ["monitor", ["religion"]],
    ["ooze", ["occultism"]],
    ["plant", ["nature"]],
    ["spirit", ["occultism"]],
    ["undead", ["religion"]],
]);

function adjustDegreeByDieValue(dieResult, degree) {
        if (dieResult === 20) {
            return degree + 1;
        } else if (dieResult === 1) {
            return degree - 1;
        }
        return degree;
}

function calculateDegreeOfSuccess(dc, rollTotal, dieResult) {
        if (rollTotal - dc >= 10) {
            return adjustDegreeByDieValue(dieResult, 3);
        } else if (dc - rollTotal >= 10) {
            return adjustDegreeByDieValue(dieResult, 0);
        } else if (rollTotal >= dc) {
            return adjustDegreeByDieValue(dieResult, 2);
        }
        return adjustDegreeByDieValue(dieResult, 1);
}

function updateInexhaustibleCountermoves(combatant) {
    if (combatant.actor.type == "npc") {
        setInexhaustibleCountermoves(game.combat.combatants.filter(a=>a.actor.type=="character"), 1)
    } else {
        setInexhaustibleCountermoves(game.combat.combatants.filter(a=>a.actor.type=="character"), 0)
    }
}

function setInexhaustibleCountermoves(combatants, val) {
    combatants.forEach(cc=> {
        if (actorFeat(cc.actor, "inexhaustible-countermoves")) {
            cc.update({
                "flags.reaction-check.inexhaustible-countermoves": val
            });
        }
    })
}

function updateCombatantReactionState(combatant, newState, actionName=undefined) {
    if (!newState) {
        if (!hasReaction(combatant, actionName) && game.user.isGM) {
            ui.notifications.warn(`${combatant.name} does not have reaction anymore`);
            return;
        }
        if (actionName == "attack-of-opportunity") {
            if (combatant?.flags?.['reaction-check']?.['triple-opportunity']) {
                combatant.update({
                    "flags.reaction-check.triple-opportunity": combatant['flags']['reaction-check']['triple-opportunity'] - 1
                });
                return;
            }
            if (combatant?.flags?.['reaction-check']?.['combat-reflexes']) {
                combatant.update({
                    "flags.reaction-check.combat-reflexes": combatant['flags']['reaction-check']['combat-reflexes'] - 1
                });
                return;
            }
            if (combatant?.flags?.['reaction-check']?.['inexhaustible-countermoves']) {
                combatant.update({
                    "flags.reaction-check.inexhaustible-countermoves": combatant['flags']['reaction-check']['inexhaustible-countermoves'] - 1
                });
                return;
            }
        } else if (actionName == "opportune-riposte") {
            if (combatant?.flags?.['reaction-check']?.['reflexive-riposte']) {
                combatant.update({
                    "flags.reaction-check.reflexive-riposte": combatant['flags']['reaction-check']['reflexive-riposte'] - 1
                });
                return;
            }
            if (combatant?.flags?.['reaction-check']?.['inexhaustible-countermoves']) {
                combatant.update({
                    "flags.reaction-check.inexhaustible-countermoves": combatant['flags']['reaction-check']['inexhaustible-countermoves'] - 1
                });
                return;
            }
        }
        combatant.update({
            "flags.reaction-check.state": false
        });
    } else {
        if (combatant.actor.type == "npc") {
            if (actorAction(combatant.actor, "triple-opportunity")) {
                combatant.update({
                    "flags.reaction-check.triple-opportunity": 2
                });
            }
        } else {
            if (actorFeat(combatant.actor, "combat-reflexes")) {
                combatant.update({
                    "flags.reaction-check.combat-reflexes": 1
                });
            }
            if (actorFeat(combatant.actor, "reflexive-riposte")) {
                combatant.update({
                    "flags.reaction-check.reflexive-riposte": 1
                });
            }
        }

        combatant.update({
            "flags.reaction-check.state": true
        });
    }
}

function getEnemyDistance(token, target) {
    return new CONFIG.Token.objectClass(token).distanceTo(new CONFIG.Token.objectClass(target))
}

function nonReach(arr) {
    return !arr.find(b=>b.startsWith("reach"))
}

function actorHeldWeapon(actor) {
    return actor?.system?.actions?.filter(a=>a.ready)
}

function hasReachWeapon(actor) {
    return actor?.system?.actions
        ?.filter(a=>a.ready)
        ?.filter(a=>a?.weaponTraits?.find(b=>b.name=="reach") || a?.traits?.find(b=>b.name.startsWith("reach")))
        ?.length != 0
}

function isTargetCharacter(message) {
    return "character" == message?.target?.actor?.type;
}

function _uuid(obj) {
    return "@UUID["+obj.uuid+"]";
}

function countReaction(combatant, actionName=undefined) {
    var count = 0;
    if (combatant) {
        if (combatant?.flags?.["reaction-check"]?.state) {
            count += 1;
        }
        if (actionName == "attack-of-opportunity") {
            count += combatant?.flags?.['reaction-check']?.['triple-opportunity'] ?? 0;
            count += combatant?.flags?.['reaction-check']?.['combat-reflexes'] ?? 0;
            count += combatant?.flags?.['reaction-check']?.['inexhaustible-countermoves'] ?? 0;
        } else if (actionName == "opportune-riposte") {
            count += combatant?.flags?.['reaction-check']?.['reflexive-riposte'] ?? 0;
            count += combatant?.flags?.['reaction-check']?.['inexhaustible-countermoves'] ?? 0;
        }
    }
    return count;
}

function hasReaction(combatant, actionName=undefined) {
    return countReaction(combatant, actionName) > 0;
}

function characterWithReaction() {
    return actorWithReactionForType("character");
}

function npcWithReaction() {
    return actorWithReactionForType("npc");
}

function actorWithReactionForType(type) {
    return game.combat.turns.filter(a => a.actor.type == type).filter(a=>hasReaction(a));
}

function hasCondition(actor, con) {
    return actor && actor?.itemTypes?.condition?.find((c => c.type == "condition" && con === c.slug))
}

function hasEffect(actor, eff) {
    return actor && actor?.itemTypes?.effect?.find((c => eff === c.slug))
}

function actorAction(actor, action) {
    return actor?.itemTypes?.action?.find((c => action === c.slug))
}

function actorSpell(actor, spell) {
    return actor?.itemTypes?.spell?.find((c => spell === c.slug))
}

function actorFeat(actor, feat) {
    return actor?.itemTypes?.feat?.find((c => feat === c.slug))
}

function canReachEnemy(attackerToken, defendToken, defendActor) {
    var distance = getEnemyDistance(attackerToken, defendToken);
    return distance <= 5 || (distance <= 10 && hasReachWeapon(defendActor))
}

function adjacentEnemy(attackerToken, defendToken) {
    return getEnemyDistance(attackerToken, defendToken) <= 5
}

async function reactionWasUsedChat(uuid, combatant) {
    var content = await renderTemplate("./modules/pf2e-reaction/templates/used.hbs", {uuid:uuid,combatant:combatant});

    var whispers = ChatMessage.getWhisperRecipients("GM").map((u) => u.id);
    if (combatant.players) {
        whispers = whispers.concat(combatant.players.map((u) => u.id));
    }

    ChatMessage.create({
        flavor: '',
        user: null,
        speaker: {
            scene: null,
            actor: null,
            token: null,
            alias: "System"
        },
        type: CONST.CHAT_MESSAGE_TYPES.OOC,
        content: content,
        whisper: whispers
    });
}

async function postInChatTemplate(uuid, combatant, actionName=undefined, skipDeath=false) {
    if((combatant?.actor?.system?.attributes?.hp?.value <= 0 || hasCondition(combatant?.actor, "unconscious") || hasCondition(combatant?.actor, "dying")) && !skipDeath) {
        return
    }
    var text = game.i18n.format("pf2e-reaction.ask", {uuid:uuid, name:combatant.token.name});
    var content = await renderTemplate("./modules/pf2e-reaction/templates/ask.hbs", {text:text});
    var check = {
        cId: combatant._id,
        actionName: actionName
    }

    var whispers = ChatMessage.getWhisperRecipients("GM").map((u) => u.id);
    if (combatant.players) {
        whispers = whispers.concat(combatant.players.map((u) => u.id));
    }

    if (game.messages.size > 0 && content == game.messages.contents[game.messages.size-1].content) {
        check['count'] = 2
        check['content'] = content
        check['uuid'] = uuid
        check['reactions'] = countReaction(combatant, actionName)

        text = game.i18n.format("pf2e-reaction.askMultiple", {uuid:uuid, name:combatant.token.name, count: 2});
        content = await renderTemplate("./modules/pf2e-reaction/templates/ask.hbs", {text:text});

        game.messages.contents[game.messages.size-1].update({
            'content': content,
            "flags.reaction-check": check
        })
    } else if (game.messages.size > 0 && content == game.messages.contents[game.messages.size-1]?.flags?.["reaction-check"]?.content) {
        var count = game.messages.contents[game.messages.size-1]?.flags?.["reaction-check"]?.count + 1;
        text = game.i18n.format("pf2e-reaction.askMultiple", {uuid:uuid, name:combatant.token.name, count: count});
        content = await renderTemplate("./modules/pf2e-reaction/templates/ask.hbs", {text:text});

        game.messages.contents[game.messages.size-1].update({
            'content': content,
            "flags.reaction-check.count": count,
            "flags.reaction-check.reactions": countReaction(combatant, actionName)
        })
    } else {
        ChatMessage.create({
            flavor: '',
            user: null,
            speaker: {
                scene: null,
                actor: null,
                token: null,
                alias: "System"
            },
            type: CONST.CHAT_MESSAGE_TYPES.OOC,
            content: content,
            whisper: whispers,
            flags: {"reaction-check": check}
        });
    }
}

function checkCombatantTriggerAttackOfOpportunity(actorType, actorId, token) {
    var filteredType = ((actorType  == "npc") ? 'character' : 'npc')
    game?.combats?.active?.combatants
        .filter((c=>c.actorId != actorId && c.actor.type == filteredType && hasReaction(c, "attack-of-opportunity")))
        .filter((cc=>actorAction(cc.actor, "attack-of-opportunity")))
        .forEach(cc => {
            var hasStrike = cc.token.actor.system.actions?.filter((e=>"strike"===e.type && e.ready));
            if (hasStrike.length>0) {
                var isReach = actorType  == "npc"
                    ? hasStrike.filter((e=>e.weaponTraits.find(b=>b.name==="reach")))
                    : hasStrike.filter((e=>e.traits.find(b=>b.name.startsWith("reach"))));

                var reachValue = Settings.weaponRange;
                if (isReach.length>0) {
                    reachValue = Settings.weaponReachRange;
                    if (filteredType == "npc") {
                        var rV = Math.min.apply(null, isReach.map(a=>a.traits).flat()
                            .filter(b=>b.name.startsWith("reach"))
                            .map(c=>c.name)
                            .map(c=>c.split('-').slice(-1)[0])
                        );
                        if (!isNaN(rV)) {
                            reachValue = rV
                        }
                    }
                }

                if (getEnemyDistance(token, cc.token)<= reachValue) {
                    postInChatTemplate(attack_of_opportunity, cc, "attack-of-opportunity");
                }
            }
        })
}

function checkRingmasterIntroduction(combatant) {
    if (combatant?.actor?.type == "character") {
        characterWithReaction()
            .filter(a=>a.tokenId != combatant.tokenId)
            .filter(a=>hasReaction(a))
            .forEach(cc => {
                if (actorFeat(cc.actor, "ringmasters-introduction")) {
                    postInChatTemplate(ringmasters_introduction, cc);
                }
            })
    }
}

function messageType(message, type) {
    return type == message?.flags?.pf2e?.context?.type;
}

function failureMessageOutcome(message) {
    return "failure" == message?.flags?.pf2e?.context?.outcome;
}

function criticalFailureMessageOutcome(message) {
    return "criticalFailure" == message?.flags?.pf2e?.context?.outcome;
}

function successMessageOutcome(message) {
    return "success" == message?.flags?.pf2e?.context?.outcome;
}

function criticalSuccessMessageOutcome(message) {
    return "criticalSuccess" == message?.flags?.pf2e?.context?.outcome;
}

function anyFailureMessageOutcome(message) {
    return failureMessageOutcome(message) || criticalFailureMessageOutcome(message);
}

function anySuccessMessageOutcome(message) {
    return successMessageOutcome(message) || criticalSuccessMessageOutcome(message);
}

function checkCourageousOpportunity(message) {
    ("character" == message.actor?.type ? npcWithReaction() : characterWithReaction())
        .filter(a=>actorFeat(a.actor, "courageous-opportunity"))
        .filter(cc=>canReachEnemy(message.token, cc.token, cc.actor))
        .filter(a=>hasEffect(a.actor, "spell-effect-inspire-courage"))
        .forEach(cc => {
            postInChatTemplate(courageous_opportunity, cc);
        });
}

function messageWithTrait(message, trait) {
    return message?.item?.system?.traits?.value?.includes(trait) || message?.item?.castingTraits?.includes(trait)
}

function messageWithAnyTrait(message, traits) {
    return traits.some(a=>messageWithTrait(message, a))
}

function checkImplementsInterruption(message) {
    if ("npc" == message.actor?.type && hasEffect(message.actor, "effect-exploit-vulnerability")) {
        characterWithReaction()
        .filter(a=>actorAction(a.actor, "implements-interruption"))
        .filter(cc=>canReachEnemy(message.token, cc.token, cc.actor))
        .forEach(cc => {
            postInChatTemplate(implements_interruption, cc);
        });
    }
}

export default function reactionHooks() {
    $(document).on('click', '.reaction-check', async function () {
        var mid = $(this).parent().parent().parent().data('message-id');
        if (mid) {
            var mes = game.messages.get(mid);
            var t = mes.flags['reaction-check'].cId;
            var reactions = mes.flags['reaction-check'].reactions;
            var count = mes.flags['reaction-check'].count;
            var uuid = mes.flags['reaction-check'].uuid;
            if (t) {
                var combatant = game.combat.turns.find(a=>a._id === t);
                if (combatant) {
                    updateCombatantReactionState(combatant, false, mes?.flags['reaction-check']?.actionName);
                    if (reactions > 1 && count > 1) {
                        var text = game.i18n.format("pf2e-reaction.ask", {uuid:uuid, name:combatant.token.name});
                        if (count-1 > 1) {
                            text = game.i18n.format("pf2e-reaction.askMultiple", {uuid:uuid, name:combatant.token.name, count: count -1});
                        }
                        var content = await renderTemplate("./modules/pf2e-reaction/templates/ask.hbs", {text:text});
                        mes.update({
                            'content': content,
                            "flags.reaction-check.count": count - 1,
                            "flags.reaction-check.reactions": reactions - 1
                        })
                    } else {
                        mes.delete()
                    }
                }
            }
        }
    });

    $(document).on('click', '.reaction-cancel', function () {
        var mid = $(this).parent().parent().parent().data('message-id');
        if (mid) {
            game.messages.get(mid)?.delete()
        }
    });

    Hooks.on('combatTurn', async (combat, updateData, updateOptions) => {
        updateCombatantReactionState(combat.nextCombatant, true);
        updateInexhaustibleCountermoves(combat.nextCombatant);
        if (combat.nextCombatant?.actor?.type == "character") {
            npcWithReaction()
                .forEach(cc => {
                    var pg = actorAction(cc.actor, "petrifying-glance")
                    if (pg && getEnemyDistance(combat.nextCombatant.token, cc.token) <= 30) {
                        postInChatTemplate(_uuid(pg), cc);
                    }
                })
        }
        if (combat.round == 1) {
            checkRingmasterIntroduction(combat.nextCombatant)
        }
        if (actorFeat(combat.nextCombatant?.actor, "scapegoat-parallel-self")) {
            postInChatTemplate(scapegoat_parallel_self, combat.nextCombatant);
        }
    });

    Hooks.on('combatRound', async (combat, updateData, updateOptions) => {
        updateCombatantReactionState(combat.nextCombatant, true);
        updateInexhaustibleCountermoves(combat.nextCombatant);
        if (combat.nextCombatant?.actor?.type == "character") {
            npcWithReaction()
                .forEach(cc => {
                    var pg = actorAction(cc.actor, "petrifying-glance")
                    if (pg && getEnemyDistance(combat.nextCombatant.token, cc.token <= 30)) {
                        postInChatTemplate(_uuid(pg), cc);
                    }
                })
        }
        if (actorFeat(combat.nextCombatant?.actor, "scapegoat-parallel-self")) {
            postInChatTemplate(scapegoat_parallel_self, combat.nextCombatant);
        }
    });

    Hooks.on('combatStart', async combat => {
        combat.turns.forEach(cc =>{
            updateCombatantReactionState(cc, true)
        });
        updateInexhaustibleCountermoves(combat.turns[0]);
        checkRingmasterIntroduction(combat.turns[0]);
    });

    Hooks.on('createCombatant', async combatant => {
        if (game.user?.isGM) {
            updateCombatantReactionState(combatant, true)
        }
    });

    Hooks.on('renderChatMessage', (app, html, msg) => {
        if (msg.user.isGM || Settings.showToPlayers) {
            return
        }
        if (app?.flags?.["reaction-check"]) {
    		html.addClass('hide-reaction-check');
		    html.hide();
        }
    });

    Hooks.on("renderActorSheet", (sheet, html, data)=>{
        if (game.user?.isGM && sheet.actor?.type === "npc" && sheet.token && Settings.recallKnowledge) {
            var skills = Array.from(new Set(sheet.object.system.traits.value.flatMap((t) => identifySkills.get(t) ?? [])));
            var dc = html.find(".recall-knowledge .section-body .identification-skills").eq(0).text().trim().match(/\d+/g)[0];
            skills.forEach(skill => {
                var loc_skill=game.i18n.localize("PF2E.Skill"+skill.replace(/^\w/, (c) => c.toUpperCase()))
                var rec=game.i18n.localize("PF2E.RecallKnowledge.Label")
                var but = document.createElement('button');
                but.className = 'gm-recall-knowledge-'+skill
                but.textContent = rec+': '+loc_skill
                but.onclick = function () {
                    let content = 'To Recall Knowledge '+(sheet?.token?.name?sheet?.token?.name:'') +', roll:';
                    content += '<br>@Check[type:'+skill+'|dc:'+dc+'|traits:secret,action:recall-knowledge]';
                    ChatMessage.create({
                        content: TextEditor.enrichHTML(content, { async: false }),
                        speaker: ChatMessage.getSpeaker({ token: sheet.token }),
                    }).then();
                };
                html.find(".recall-knowledge").append(but);
            });
        }
    });

    Hooks.on('createItem', (effect, data, id) => {
        if ("effect-raise-a-shield" == effect.slug && effect.actor.type ==  "character") {
            var currCom = game.combat.turns.find(a=>a.actorId == effect.actor.id);
            var withShield = game.combat.turns.filter(a => a.actor.type == "character")
                .filter(a=>hasEffect(a.actor, "effect-raise-a-shield"));
            if (hasReaction(currCom) && actorFeat(currCom.actor, "shield-wall")) {
                var adjacent = withShield
                .filter(a=>adjacentEnemy(a.token, currCom.token));
                if (adjacent.length > 1) {
                    postInChatTemplate(shield_wall, currCom);
                }
            }
            withShield.filter(a=>hasReaction(a) && actorFeat(a.actor, "shield-wall"))
            .filter(a=>a.id != currCom.id)
            .filter(a=>adjacentEnemy(a.token, currCom.token))
            .forEach(cc => {
                postInChatTemplate(shield_wall, cc);
            });
        }
    });

    Hooks.on('preUpdateToken', (tokenDoc, data, deep, id) => {
        if (game?.combats?.active && (data.x > 0 || data.y > 0)) {
            checkCombatantTriggerAttackOfOpportunity(tokenDoc.actor?.type, tokenDoc.actorId, tokenDoc);
            if (tokenDoc.actor.type == "npc") {
                characterWithReaction()
                    .filter(a=>a.tokenId != tokenDoc._id)
                    .filter(a=>actorFeat(a.actor, "no-escape"))
                    .forEach(cc => {
                        if (canReachEnemy(tokenDoc, cc.token, cc.actor)) {
                            postInChatTemplate(no_escape, cc);
                        }
                    });
            }

            checkCourageousOpportunity({"actor" : tokenDoc.actor, "token": tokenDoc})
            checkImplementsInterruption({"actor" : tokenDoc.actor, "token": tokenDoc})

            handleHomebrewMessages({
                'token': tokenDoc,
                'item': {
                    'type': 'action',
                    'system': {
                        'traits': {
                            'value': ['move']
                        }
                    }
                },
                'actor': {
                    'type': tokenDoc.actor?.type
                }
            })
        }
    });

    Hooks.on('preCreateChatMessage',async (message, user, _options, userId)=>{
        if (game?.combats?.active) {
            if (message?.flags?.pf2e?.appliedDamage && !message?.flags?.pf2e?.appliedDamage?.isHealing) {
                if (message.actor.system?.attributes?.hp?.value == 0) {
                    if (hasReaction(message?.token?.combatant)) {
                        if (actorAction(message?.actor, "ferocity")) {
                            postInChatTemplate(ferocity, message?.token?.combatant, undefined, true);
                        }
                        if (actorFeat(message?.actor, "cheat-death")) {
                            postInChatTemplate(cheat_death, message?.token?.combatant, undefined, true);
                        }
                        if (actorFeat(message?.actor, "ruby-resurrection")) {
                            postInChatTemplate(ruby_resurrection, message?.token?.combatant, undefined, true);
                        }
                    }
                    // ally
                    if ("character" == message?.actor?.type) {
                        characterWithReaction()
                        .filter(a=>a.actorId != message?.actor?._id)
                        .filter(a=>actorFeat(a.actor, "rapid-response"))
                        .forEach(cc => {
                            postInChatTemplate(rapid_response, cc);
                        });
                    }

                }
            }

            if (messageWithTrait(message, "auditory")) {
                checkCourageousOpportunity(message);
            }
            if (messageWithAnyTrait(message, ["concentrate", "manipulate"])) {
                checkImplementsInterruption(message);
            }

            if (
                (messageType(message, 'attack-roll') && message?.flags?.pf2e?.context?.domains.includes("ranged-attack-roll"))
                || (message?.item?.type == 'action' && messageWithAnyTrait(message, ["manipulate","move"]))
            ) {
                checkCombatantTriggerAttackOfOpportunity(message.actor?.type, message.actor._id, message.token);
                checkCourageousOpportunity(message);

                if (message?.item?.type == 'action' && messageWithAnyTrait(message, ["manipulate","move"])) {
                    checkImplementsInterruption(message);
                }
            } else if (user?.flags?.pf2e?.origin?.type == 'action') {
                var actId = user.flags?.pf2e?.origin?.uuid.split('.').slice(-1)[0]
                if (game?.packs?.get("pf2e.actionspf2e")._source.find(a=>a._id==actId)?.system?.traits?.value.includes("manipulate")) {
                    checkCombatantTriggerAttackOfOpportunity(message.actor?.type, message.actor._id, message.token);
                    checkImplementsInterruption(message);
                }
            }

            if (message?.flags?.pf2e?.casting || messageType(message, 'spell-cast')) {
                ("character" == message?.actor?.type ? npcWithReaction() : characterWithReaction())
                    .forEach(cc => {
                        if (canReachEnemy(message.token, cc.token, cc.actor)) {
                            if (actorFeat(cc.actor, "mage-hunter")) {
                                postInChatTemplate(mage_hunter, cc);
                            }
                        }
                    })
                if (message?.item && "character" == message?.actor?.type) {
                    if (!message?.item?.isCantrip) {
                        characterWithReaction()
                            .filter(a=>a.actorId != message?.actor?._id)
                            .filter(a=>getEnemyDistance(message.token, a.token) <= 30)
                            .forEach(cc => {
                                if (actorFeat(cc.actor, "accompany")) {
                                    postInChatTemplate(accompany, cc);
                                }
                            })
                    }

                    if (actorFeat(message?.actor, "verdant-presence") && message?.item?.system?.traditions.value.includes("primal")) {
                        postInChatTemplate(verdant_presence, message?.token?.combatant);
                    }

                    let spellRange = message?.item?.system?.range?.value?.match(/\d+/g);
                    spellRange = spellRange ? spellRange[0] : 0;

                    characterWithReaction()
                        .filter(a=>a.actorId != message?.actor?._id)
                        .filter(a=>getEnemyDistance(message.token, a.token) <= spellRange)
                        .filter(a=>actorFeat(a.actor, "spell-relay"))
                        .forEach(cc => {
                            postInChatTemplate(spell_relay, cc);
                        })

                }

            } else if (messageType(message, "spell-attack-roll")) {
                if (hasReaction(message?.target?.token?.combatant)) {
                    if (criticalFailureMessageOutcome(message)) {
                        if (actorFeat(message?.target?.actor, "mirror-shield")) {
                            postInChatTemplate(mirror_shield, message?.target?.token?.combatant);
                        }
                    }
                    if (actorAction(message?.target?.actor, "ring-bell")
                            && getEnemyDistance(message.token, message.target.token)<=30
                            && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, message.target.token.combatant);
                    }
                }
                if (isTargetCharacter(message)) {
                    characterWithReaction()
                    .filter(a=>a.actorId != message?.target?.actor._id)
                    .forEach(cc => {
                        if (actorAction(cc?.actor, "ring-bell")
                            && getEnemyDistance(cc?.token, message.token)<=30
                            && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, cc);
                        }
                    })
                }
            } else if (messageType(message, 'attack-roll')) {
                if (hasReaction(message?.target?.token?.combatant)) {
                    if (isTargetCharacter(message)) {
                        if (actorFeat(message?.target?.actor, "nimble-dodge") && !hasCondition(message?.target?.actor,"encumbered")) {
                            postInChatTemplate(nimble_dodge_feat, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "airy-step")) {
                            postInChatTemplate(airy_step_feat, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "farabellus-flip")) {
                            postInChatTemplate(farabellus_flip, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "reactive-shield") && anySuccessMessageOutcome(message) && message?.item?.isMelee) {
                            postInChatTemplate(reactive_shield, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "pirouette") && hasEffect(message?.target?.actor, "stance-masquerade-of-seasons-stance")) {
                            postInChatTemplate(pirouette, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "fiery-retort") && adjacentEnemy(message.token, message.target.token)
                            && (message?.item?.isMelee|| message?.item?.traits?.has("unarmed"))) {
                            postInChatTemplate(fiery_retort, message.target.token.combatant);
                        }
                        if (actorFeat(message?.target?.actor, "knights-retaliation")
                            && message?.actor?.system.traits.value.includes("undead")
                            && criticalFailureMessageOutcome(message)
                        ) {
                            postInChatTemplate(knights_retaliation, message.target.token.combatant);
                        }
                        if (actorAction(message?.target?.actor, "ring-bell")
                            && getEnemyDistance(message.token, message.target.token)<=30
                            && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, message.target.token.combatant);
                        }
                    } else {
                        if (actorAction(message?.target?.actor, "nimble-dodge") && !hasCondition(message?.target?.actor,"encumbered")) {
                            postInChatTemplate(nimble_dodge_action, message.target.token.combatant);
                        }
                        if (actorAction(message?.target?.actor, "airy-step")) {
                            postInChatTemplate(airy_step_action, message.target.token.combatant);
                        }
                    }
                }
                if (criticalFailureMessageOutcome(message) && hasReaction(message?.target?.token?.combatant, "opportune-riposte")) {
                    if (message.actor?.type == 'npc') {
                        if (canReachEnemy(message.token, message?.target?.token, message?.target?.actor) && actorFeat(message?.target?.actor, "opportune-riposte")) {
                            postInChatTemplate(opportune_riposte, message.target.token.combatant, "opportune-riposte");
                        }
                    } else {
                        if (canReachEnemy(message.token, message?.target?.token, message?.target?.actor) && actorAction(message?.target?.actor, "opportune-riposte")) {
                            postInChatTemplate(opportune_riposte_action, message.target.token.combatant, "opportune-riposte");
                        }
                    }
                }
                if (criticalFailureMessageOutcome(message) && hasReaction(message?.target?.token?.combatant)) {
                    if (actorFeat(message?.target?.actor, "dueling-riposte") && hasEffect(message.target.actor, "effect-dueling-parry")) {
                        postInChatTemplate(dueling_riposte, message.target.token.combatant);
                    }
                    if (actorFeat(message?.target?.actor, "twin-riposte") && canReachEnemy(message.token, message?.target?.token, message?.target?.actor)
                        && (hasEffect(message.target.actor, "effect-twin-parry")||hasEffect(message.target.actor, "effect-twin-parry-parry-trait"))) {
                        postInChatTemplate(twin_riposte, message.target.token.combatant);
                    }
                }
                if (anyFailureMessageOutcome(message)) {
                    if (hasReaction(message?.token?.combatant)) {
                        if (actorFeat(message?.actor, "perfect-clarity")) {
                            postInChatTemplate(perfect_clarity, message?.token?.combatant);
                        }
                    }
                }

                if (!isTargetCharacter(message)) {
                    npcWithReaction()
                    .filter(a=>a.actorId != message?.target?.actor._id)
                    .forEach(cc => {
                        if (adjacentEnemy(message.token, cc.token)) {
                            var ab = actorAction(cc.actor, "avenging-bite");
                            if (ab) {
                                postInChatTemplate(_uuid(ab), cc?.token?.combatant);
                            }
                        }
                    })
                } else {
                    characterWithReaction()
                    .filter(a=>a.actorId != message?.target?.actor._id)
                    .forEach(cc => {
                        if (actorAction(cc?.actor, "ring-bell")
                            && getEnemyDistance(cc?.token, message.token)<=30
                            && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, cc);
                        }
                    })
                }

                //Hit by
                if (anySuccessMessageOutcome(message)) {
                    if (hasReaction(message?.token?.combatant)) {
                        if (message?.item?.system?.attackEffects?.value.includes("improved-grab")) {
                            var fs = actorAction(message?.actor, "fast-swallow");
                            if (fs) {
                                postInChatTemplate(_uuid(fs), message?.token?.combatant);
                            }
                        }
                    }
                    if (hasReaction(message?.target?.token?.combatant)) {
                        if (actorAction(message?.target?.actor, "wicked-thorns")) {
                            if (message?.item?.traits.has("unarmed") || (message?.item?.isMelee && nonReach(message?.item?.traits))) {
                                postInChatTemplate(wicked_thorns, message.target.token.combatant);
                            }
                        }
                    }

                    if (isTargetCharacter(message)) {
                        const rr = message.rolls.at(0);
                        let newR = calculateDegreeOfSuccess(message?.flags?.pf2e?.context?.dc?.value, rr._total - 2, rr.dice.at(0).total)

                        if (rr.degreeOfSuccess != newR) {
                            characterWithReaction()
                                .filter(a=>a.actorId != message?.target?.actor._id)
                                .filter(cc=>canReachEnemy(message?.target?.token, cc.token, cc.actor))
                                .forEach(cc => {
                                    if (actorFeat(cc.actor, "guardians-deflection-fighter")) {
                                        postInChatTemplate(guardians_deflection_fighter, cc);
                                    }
                                    if (actorFeat(cc.actor, "guardians-deflection-swashbuckler")) {
                                        postInChatTemplate(guardians_deflection_swashbuckler, cc);
                                    }
                                })
                        }
                    }
                }

                //Hit by crit
                if (criticalSuccessMessageOutcome(message)) {
                    if (hasReaction(message?.target?.token?.combatant)) {
                        var vs = actorAction(message?.target?.actor, "vengeful-spite");
                        if (vs) {
                            postInChatTemplate(_uuid(vs), message.target?.token?.combatant);
                        }
                        if (canReachEnemy(message.token, message?.target?.token, message?.target?.actor) && actorFeat(message?.target?.actor, "furious-vengeance")) {
                            postInChatTemplate(furious_vengeance, message.target.token.combatant);
                        }
                        if (adjacentEnemy(message.token, message?.target?.token, message?.target?.actor)) {
                            if (message?.item?.isMelee || message?.item?.traits?.has("unarmed")) {
                                if (message?.target?.actor?.system?.resources?.focus?.value > 0) {
                                    if (actorFeat(message?.target?.actor, "storm-retribution")) {
                                        postInChatTemplate(storm_retribution, message.target.token.combatant);
                                    }
                                }
                            }
                        }
                    }
                    if (hasReaction(message?.token?.combatant)) {
                        if (actorFeat(message?.actor, "tangle-of-battle") && adjacentEnemy(message.target.token, message?.token)) {
                            postInChatTemplate(tangle_of_battle, message.token.combatant);
                        }
                        if (actorFeat(message?.actor, "clever-gambit") && hasEffect(message?.target?.actor, "effect-recall-knowledge-identified")) {
                            postInChatTemplate(clever_gambit, message.token.combatant);
                        }
                    }
                }
            } else if (messageType(message, 'perception-check')) {
                if (failureMessageOutcome(message)) {
                    if (hasReaction(message?.token?.combatant)) {
                        if (actorFeat(message?.actor, "spiritual-guides")) {
                            postInChatTemplate(spiritual_guides, message.token.combatant);
                        }
                    }
                }
                if (message?.flags?.pf2e?.origin?.uuid) {
                    var origin = await fromUuid(message?.flags?.pf2e?.origin?.uuid);
                    if (hasReaction(origin?.actor?.combatant)) {
                        if (successMessageOutcome(message)) {
                            if (actorFeat(origin?.actor, "convincing-illusion") && origin?.traits?.has("illusion")) {
                                postInChatTemplate(convincing_illusion, origin?.actor?.combatant);
                            }
                        }
                    }
                }
            } else if (messageType(message, 'skill-check')) {
                if (isTargetCharacter(message) && anySuccessMessageOutcome(message)) {
                    characterWithReaction()
                    .filter(a=>a.actorId != message?.target?.actor._id)
                    .forEach(cc => {
                        if (message?.flags?.pf2e?.context?.options.find(bb=>bb=="action:grapple")) {
                            if (getEnemyDistance(message.target.token, cc.token) <= 15 && getEnemyDistance(message.token, cc.token) <= 15){
                                if (actorAction(cc.actor, "liberating-step")) {
                                    postInChatTemplate(liberating_step, cc);
                                }
                            }
                        }
                    })
                }
                if (failureMessageOutcome(message)) {
                    if (hasReaction(message?.token?.combatant)) {
                        if (actorFeat(message?.actor, "spiritual-guides")) {
                            postInChatTemplate(spiritual_guides, message.token.combatant);
                        }
                    }
                }

            } else if (messageType(message, 'damage-roll')) {
                //15 ft damage you
                if(hasReaction(message?.target?.token?.combatant)) {
                    if (actorFeat(message?.target?.actor, "verdant-presence")) {
                        postInChatTemplate(verdant_presence, message.target.token.combatant);
                    }
                    if (actorAction(message?.target?.actor, "amulets-abeyance") && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                        postInChatTemplate(amulets_abeyance, message?.target?.token?.combatant);
                    }

                    if (message?.item?.system?.damageRolls) {
                        var dTypes = Object.values(message?.item?.system?.damageRolls).map(a=>a.damageType);
                        if (dTypes.filter(a=> a== "bludgeoning" || a == "piercing" || a== "slashing").length > 0) {
                            if (actorFeat(message?.target?.actor, "sacrifice-armor")) {
                                postInChatTemplate(sacrifice_armor, message.target.token.combatant);
                            }
                        }

                        if (dTypes.filter(a=> ["acid", "cold", "electricity", "fire", 'poison'].includes(a)).length > 0) {
                            if (actorFeat(message?.target?.actor, "reactive-transformation")) {
                                postInChatTemplate(reactive_transformation, message.target.token.combatant);
                            }
                        }
                    }

                    if (message?.item?.isMelee && actorFeat(message?.target?.actor, "embrace-the-pain")) {
                        postInChatTemplate(embrace_the_pain, message.target.token.combatant);
                    }
                    if (adjacentEnemy(message.target.token, message.token)) {
                        var rg = actorAction(message?.target?.actor, "reactive-gnaw");
                        if (rg && message?.item?.system?.damage?.damageType == "slashing") {
                            postInChatTemplate(_uuid(rg), message.target.token.combatant);
                        }
                        var rc = actorFeat(message?.target?.actor, "retaliatory-cleansing");
                        if (rc) {
                            if (actorHeldWeapon(message?.target?.actor).filter(a=>a.slug=="holy-water" || (a.weaponTraits.filter(b=>b.name == "bomb").length > 0 && a.weaponTraits.filter(b=>b.name == "positive").length > 0)).length > 0) {
                                postInChatTemplate(retaliatory_cleansing, message.target.token.combatant);
                            }
                        }
                    } else if (getEnemyDistance(message?.target.token, message.token) <= 15) {
                        if (actorAction(message?.target?.actor, "iron-command")) {
                            postInChatTemplate(iron_command, message.target.token.combatant);
                        }
                        if (actorAction(message?.target?.actor, "selfish-shield")) {
                            postInChatTemplate(selfish_shield, message.target.token.combatant);
                        }
                        if (actorAction(message?.target?.actor, "destructive-vengeance")) {
                            postInChatTemplate(destructive_vengeance, message.target.token.combatant);
                        }
                    }
                }
                //ally damaged
                actorWithReactionForType(message?.target?.actor?.type)
                .filter(a=>a.actorId != message?.target?.actor._id)
                .forEach(cc => {
                    if (getEnemyDistance(message.target.token, cc.token) <= 15 && getEnemyDistance(message.token, cc.token) <= 15) {
                        if (actorAction(cc.actor, "glimpse-of-redemption")) {
                            postInChatTemplate(glimpse_of_redemption, cc);
                        }
                        if (actorAction(cc.actor, "liberating-step")) {
                            postInChatTemplate(liberating_step, cc);
                        }
                        if (actorAction(cc.actor, "retributive-strike")) {
                            postInChatTemplate(retributive_strike, cc);
                        }
                    }
                    if (getEnemyDistance(message.target.token, cc.token) <= 15 && hasEffect(message.actor, "effect-exploit-vulnerability")) {
                        if (actorAction(cc.actor, "amulets-abeyance")) {
                            postInChatTemplate(amulets_abeyance, cc);
                        }
                    }
                    if (getEnemyDistance(message.target.token, cc.token) <= 30) {
                        if (actorFeat(cc.actor, "denier-of-destruction")) {
                            postInChatTemplate(denier_of_destruction, cc);
                        }
                    }
                })
            } else if (messageType(message, "saving-throw")) {
                var origin = await fromUuid(message?.flags?.pf2e?.origin?.uuid);
                if (hasReaction(message?.token?.combatant)) {
                    if (anyFailureMessageOutcome(message)) {
                        if (actorFeat(message.actor, "premonition-of-clarity") && origin?.traits?.has("mental")) {
                            postInChatTemplate(premonition_of_clarity, message.token.combatant);
                        }
                        if (actorFeat(message.actor, "charmed-life")) {
                            if (message?.flags?.pf2e?.modifiers?.find(a=>a.slug=="charmed-life" && a.enabled)) {
                                updateCombatantReactionState(message.token.combatant, false);
                                reactionWasUsedChat(charmed_life, message.token.combatant);
                            } else {
                                postInChatTemplate(charmed_life, message.token.combatant);
                            }
                        }
                    }
                    if (criticalFailureMessageOutcome(message)) {
                        if (actorSpell(message.actor, "schadenfreude")) {
                            postInChatTemplate(schadenfreude, message.token.combatant)
                        }
                    }

                    if (actorAction(message?.actor, "ring-bell")
                            && getEnemyDistance(message.token, origin?.actor?.token)<=30
                            && hasEffect(origin?.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, message?.actor?.combatant);
                    }

                }
                if ("character" == message?.actor?.type) {
                    characterWithReaction()
                    .filter(a=>a.actorId != message?.actor._id)
                    .forEach(cc => {
                        if (actorAction(cc?.actor, "ring-bell")
                            && getEnemyDistance(cc?.token, origin?.actor?.token)<=30
                            && hasEffect(origin?.actor, "effect-exploit-vulnerability")) {
                            postInChatTemplate(ring_bell, cc);
                        }
                    })
                }
                if (hasReaction(origin?.actor?.combatant)) {
                    if (successMessageOutcome(message)) {
                        if (actorFeat(origin?.actor, "convincing-illusion") && origin?.traits?.has("illusion")) {
                            postInChatTemplate(convincing_illusion, origin?.actor?.combatant);
                        }
                    }
                }
            }

            handleHomebrewMessages(message)
        }
    });

    function handleHomebrewTrigger(tr, message) {
        if (tr.name == 'EnemyUseRangedAttack' && messageType(message, 'attack-roll') && message?.flags?.pf2e?.context?.domains.includes("ranged-attack-roll")) {
            return true;
        }
        if (tr.name == 'EnemyUseManipulateAction' && message?.item?.type == 'action' && message?.item?.system?.traits?.value.includes("manipulate")) {
            return true;
        }
        if (tr.name == 'EnemyUseMoveAction' && message?.item?.type == 'action' && message?.item?.system?.traits?.value.includes("move")) {
            return true;
        }
        if (tr.name == 'FailSavingThrow' && messageType(message, 'saving-throw') && anyFailureMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'CriticalFailSavingThrow' && messageType(message, 'saving-throw') && criticalFailureMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'CriticalHitCreature' && messageType(message, 'attack-roll') && criticalSuccessMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'AllyTakeDamage' && messageType(message, 'damage-roll')) {
            return true;
        }
        if (tr.name == 'ActorTakeDamage' && messageType(message, 'damage-roll')) {
            return true;
        }
        if ((tr.name == 'YouHPZero' || tr.name == "AllyHPZero")
            && message?.flags?.pf2e?.appliedDamage
            && !message?.flags?.pf2e?.appliedDamage?.isHealing
            && message.actor.system?.attributes?.hp?.value == 0) {
            return true;
        }
        if (tr.name == 'EnemyUsesTrait'
            && message?.item?.system?.traits?.value?.includes(tr.trait)) {
            return true;
        }
        if (tr.name == 'EnemyCastSpell' && (message?.flags?.pf2e?.casting || messageType(message, 'spell-cast'))) {
            return true;
        }
        if (tr.name == 'EnemyHitsActor' && messageType(message, 'attack-roll')) {
            return true;
        }
        if (tr.name == 'EnemyCriticalFailHitsActor' && messageType(message, 'attack-roll') && criticalFailureMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'EnemyCriticalHitsActor' && messageType(message, 'attack-roll') && criticalSuccessMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'EnemyFailHitsActor' && messageType(message, 'attack-roll') && anyFailureMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'ActorFailsHit' && messageType(message, 'attack-roll') && anyFailureMessageOutcome(message)) {
            return true;
        }
        if (tr.name == 'CreatureAttacksAlly' && messageType(message, 'attack-roll')) {
            return true;
        }
        if (tr.name == 'ActorFailsSkillCheck' && messageType(message, 'skill-check') && anyFailureMessageOutcome(message)) {
            return true;
        }
        return false;
    }

    function filterByDistance(t, tr, message) {
        var r = t;
        if (tr.reach) {
            r = r.filter(cc=>canReachEnemy(message.token, cc.token, cc.actor));
        } else if (tr.adjacent) {
            r = r.filter(a=>adjacentEnemy(message.token, a.token));
        } else if (tr.reachValue > 0) {
            r = r.filter(a=>getEnemyDistance(message.token, a.token) <= tr.reachValue);
        }
        return r;
    }

    function messageRequirements(message, requirements) {
        return requirements.every(a=>{
            if (a.name == 'TargetHasEffect' && hasEffect(message?.target?.actor, a.effect)) {
                return true;
            }
            if (a.name == 'ActorHasEffect' && hasEffect(message?.actor, a.effect)) {
                return true;
            }
            return false;
        })
    }


    function combatantsForTriggers(tt, message) {
        var res = [];

        tt.forEach(tr => {
            if (tr.name == 'EnemyUseRangedAttack' && messageType(message, 'attack-roll') && message?.flags?.pf2e?.context?.domains.includes("ranged-attack-roll")) {
                var t = filterByDistance(("character" == message?.actor?.type ? npcWithReaction() : characterWithReaction()), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyUseManipulateAction' && message?.item?.type == 'action' && message?.item?.system?.traits?.value.includes("manipulate")) {
                var t = filterByDistance(("character" == message?.actor?.type ? npcWithReaction() : characterWithReaction()), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyUseMoveAction' && message?.item?.type == 'action' && message?.item?.system?.traits?.value.includes("move")) {
                var t = filterByDistance(("character" == message?.actor?.type ? npcWithReaction() : characterWithReaction()), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'FailSavingThrow' && messageType(message, 'saving-throw') && anyFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'CriticalFailSavingThrow' && messageType(message, 'saving-throw') && criticalFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'CriticalHitCreature' && messageType(message, 'attack-roll') && criticalSuccessMessageOutcome(message)) {
                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'AllyTakeDamage' && messageType(message, 'damage-roll')) {
                var t = filterByDistance(actorWithReactionForType(message?.target?.actor?.type)
                .filter(a=>a.actorId != message?.target?.actor._id), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'ActorTakeDamage' && messageType(message, 'damage-roll')) {
                var t = filterByDistance([message?.target?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if ((tr.name == 'YouHPZero')
                && message?.flags?.pf2e?.appliedDamage
                && !message?.flags?.pf2e?.appliedDamage?.isHealing
                && message.actor.system?.attributes?.hp?.value == 0) {

                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if ((tr.name == "AllyHPZero")
                && message?.flags?.pf2e?.appliedDamage
                && !message?.flags?.pf2e?.appliedDamage?.isHealing
                && message.actor.system?.attributes?.hp?.value == 0) {

                var t = filterByDistance(actorWithReactionForType(message?.actor?.type)
                    .filter(a=>a.actorId != message?.actor?._id), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyUsesTrait'
                && message?.item?.system?.traits?.value?.includes(tr.trait)) {

                var t = filterByDistance(("character" == message.actor?.type ? npcWithReaction() : characterWithReaction()), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyCastSpell' && (message?.flags?.pf2e?.casting || messageType(message, 'spell-cast'))) {
                var t = filterByDistance(("character" == message.actor?.type ? npcWithReaction() : characterWithReaction()), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyHitsActor' && messageType(message, 'attack-roll')) {
                var t = filterByDistance([message?.target?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyCriticalFailHitsActor' && messageType(message, 'attack-roll') && criticalFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.target?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyCriticalHitsActor' && messageType(message, 'attack-roll') && criticalSuccessMessageOutcome(message)) {
                var t = filterByDistance([message?.target?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'EnemyFailHitsActor' && messageType(message, 'attack-roll') && anyFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.target?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'ActorFailsHit' && messageType(message, 'attack-roll') && anyFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'CreatureAttacksAlly' && messageType(message, 'attack-roll')) {
                var t = filterByDistance(("character" == message.actor?.type ? npcWithReaction() : characterWithReaction())
                    .filter(a=>a.actorId != message?.target?.actor._id), tr, message);
                res = res.concat(t);
            }
            if (tr.name == 'ActorFailsSkillCheck' && messageType(message, 'skill-check') && anyFailureMessageOutcome(message)) {
                var t = filterByDistance([message?.token?.combatant], tr, message);
                res = res.concat(t);
            }
        });

        res = [...new Map(res.map(item =>[item['actorId'], item])).values()];

        return res;
    }

    async function handleHomebrewMessages(message) {
        if (Settings.useHomebrew) {
            Settings.homebrewReactions
                .filter(a=>a.slug.length > 0 && a.uuid.length > 0 && a.triggers.length > 0)
                .filter(a=>a.triggers.filter(a=> a.name != "None").length > 0)
                .forEach(hr => {
                    var tt = hr.triggers.filter(a=> a.name != "None");
                    var requirements = hr.requirements.filter(a=> a.name != "None");
                    if (!messageRequirements(message, requirements)) {
                        return;
                    }
                    if (tt.some(a=>handleHomebrewTrigger(a, message))) {
                        combatantsForTriggers(tt, message)
                            .filter(a=>actorFeat(a.actor, hr.slug) || actorAction(a.actor, hr.slug) || actorSpell(a.actor, hr.slug))
                            .forEach(cc => {
                                postInChatTemplate(_uuid(hr), cc, undefined, tt.find(a=>a.name=="YouHPZero") != undefined);
                            })
                    }
                })
        }
    }

    Hooks.on("targetToken", (_user, token, isTargeted, opts) => {
        if (Settings.notification && game?.combats?.active && isTargeted && hasReaction(token?.combatant)) {
            if (game.user.isGM || token.combatant.players.find(a=>a.id==game.user.id)) {
                if (token?.actor?.type == "character") {
                    var nd = actorFeat(token.actor, "nimble-dodge");
                    if (nd && !hasCondition(token.actor, "encumbered")) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:nd.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                    var as = actorFeat(token.actor, "airy-step");
                    if (as) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:as.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                    var ff = actorFeat(token.actor, "farabellus-flip");
                    if (ff) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:ff.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                    var pir = actorFeat(token.actor, "pirouette");
                    if (pir && hasEffect(token.actor, "stance-masquerade-of-seasons-stance")) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:pir.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                } else {
                    var nd = actorAction(token.actor, "nimble-dodge");
                    if (nd && !hasCondition(token.actor, "encumbered")) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:nd.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                    var as = actorAction(token.actor, "airy-step");
                    if (as) {
                        var text = game.i18n.format("pf2e-reaction.notify", {uuid:as.name, name:token.name});
                        ui.notifications.info(`${_user.name} targets ${token.name}. ${text}`);
                    }
                }
            }
        }
    });

    console.log("Pf2e-reaction | --- Hooks are added");
}